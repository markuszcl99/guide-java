## 设计模式概括总结

主要考虑一下几方面内容：
- 使用场景
- 该模式的优势
- 该模式的劣势
- 该模式遵循哪些设计原则、破坏了哪些原则

## 设计原则
- 单一职责原则：类设计要功能单一，高内聚，低耦合
- 开放封闭原则：对扩展开放，对修改关闭
- 依赖倒置原则：类与类之间的依赖关系，不要依赖其实现，要依赖其抽象
- 接口隔离原则：一个接口通常只需要定义与职责相关的功能，不要定义不需要的方法，减少不必要的依赖
- 里氏替换原则：在程序执行的任何环节，子类都能无缝替换其父类实现
- 最少知识原则：类与类之间的依赖关系，要避免类开放细节，对外黑盒化，尽量减少外部对类的了解

## 创建型
> 创建型设计模式专注于如何实例化或一组相关对象。每种模式都有其使用的场景和优缺点，并且他们大多数都遵循了软件设计的核心原则，如单一职责原则、开闭原则和依赖倒置原则。然后，在某些情况下，为了达到特定的设计目的，可能会有意或无意地违背这些原则。在实际应用中，应根据具体需求和上下文选择最合适的设计模式

### 单例模式
- 使用场景: 当需要确保一个类只有一个实例，并且提供一个全局访问点时使用。 
- 优势:
  - 资源控制，节省系统资源
  - 对唯一实例的受控访问
  - 缩减命名空间
  - 控制实例化过程，可以延迟初始化
- 劣势: 
  - 单例模式可能导致代码高度耦合（全局访问点、难以替换和扩展）
  - 在多线程环境下，需要特别小心地编写代码以确保线程安全
- 设计原则
  - 遵循: 
    - 单一职责原则（取决于用户怎么使用单例，如果一个单例提供了多种职责，那就不遵循）
    - 遵循开放封闭原则（扩展开放，修改关闭。同样也取决于用户怎么设计单例模式）
  - 破坏:
    - 破坏了依赖导致原则，因为它通常直接依赖具体类
    - 可能破坏了单一职责原则
  - 总之：对于单例模式所遵循(或者破坏)的原则，并没有具体的标准，取决于用户怎么使用，单例模式只是保证了实例全局唯一
### 工厂方法模式
- 使用场景: 当一个类需要创建的对象的类型由其子类决定时使用
- 优势:
  - 提高了系统的可扩展性，因为新增产品类不需要修改现有系统代码
  - 提高了系统的可维护性，因为创建对象的代码被集中管理
- 劣势: 
  - 可能导致系统中类的个数增加，增加了系统的复杂度
- 设计原则: 
  - 遵循了依赖导致原则（依赖抽象，不依赖具体类）
  - 遵循了开闭原则（通过继承和重写实现扩展）
  - 无明显违背设计原则

### 抽象工厂模式
- 使用场景: 当创建一系列相关或相互依赖的对象时，且不需要指定他们具体的类（例如，汽车制造的过程就是一个典型的抽象工厂模式的模型）
  - 用户（客户端）不关注如何造出车，只关心去哪个厂商（抽象工厂）获取车（产品）
  - 汽车厂商采购零件，每个零件不可能独立研发，例如电池、车漆、轮胎等。交由各个产品工厂（产品族工厂）生产
- 优势:
  - 使得一系列产品的创建与使用解耦，确保产品家族在不同平台间的一致性
- 劣势:
  - 难以支持新种类的产品，这是因为抽象工厂接口确定了可以创建的产品集合
  - 增加了系统的抽象性和复杂度
- 设计原则: 
  - 遵循了开闭原则和依赖导致原则
  - 当新增产品时可能违背开闭原则，因为可能需要修改抽象工厂的接口
## 结构型

## 行为型